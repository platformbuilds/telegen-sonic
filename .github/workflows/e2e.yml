name: e2e

on:
  # 1) Owner/admin manually kicks off a release scan + PR with a tag
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (format: release/mark-vMAJOR-MINOR-PATCH)'
        required: true
        type: string

  # 2) The actual release runs ONLY after the vulncheck PR is merged
  pull_request_target:
    types: [closed]

permissions:
  contents: write
  packages: write
  id-token: write
  pull-requests: write

env:
  IMAGE_NAME: ghcr.io/${{ github.repository }}
  GO_VERSION: '1.23.x'
  RELEASE_TAG: ${{ inputs.tag }}

concurrency:
  group: e2e-${{ github.ref || github.run_id }}
  cancel-in-progress: false

# --------------------------------------------------------------------
# PATH A: Manual dispatch -> create tag, run govulncheck (pure JSON), open PR
# --------------------------------------------------------------------
jobs:
  create-tag:
    if: github.event_name == 'workflow_dispatch'
    name: Create tag (manual, owner/admin only)
    runs-on: ubuntu-latest
    steps:
      - name: "Guard: only repository admins/owners may run releases"
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner.toLowerCase();
            const repo  = context.repo.repo;
            const actor = context.actor.toLowerCase();
            if (actor === owner) return; // personal repo case
            const { data } = await github.rest.repos.getCollaboratorPermissionLevel({ owner, repo, username: context.actor });
            if (data.permission !== 'admin') core.setFailed('Only repository admins/owners may run the release workflow.');

      - name: Validate tag format
        run: |
          TAG="${{ env.RELEASE_TAG }}"
          if [[ ! "$TAG" =~ ^release/mark-v[0-9]+-[0-9]+-[0-9]+$ ]]; then
            echo "Tag must match release/mark-vMAJOR-MINOR-PATCH (e.g. release/mark-v1-2-3)"
            exit 1
          fi

      - name: Create git tag if missing
        uses: actions/github-script@v7
        with:
          script: |
            const tag   = process.env.RELEASE_TAG;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            try {
              await github.rest.git.getRef({ owner, repo, ref: `tags/${tag}` });
              core.info(`Tag ${tag} already exists.`);
            } catch (e) {
              if (e.status !== 404) throw e;
              await github.rest.git.createRef({ owner, repo, ref: `refs/tags/${tag}`, sha: context.sha });
              core.info(`Created refs/tags/${tag}`);
            }

      - name: Ensure draft GitHub Release exists
        uses: actions/github-script@v7
        with:
          script: |
            const tag   = process.env.RELEASE_TAG;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            try {
              await github.rest.repos.getReleaseByTag({ owner, repo, tag });
            } catch (e) {
              if (e.status !== 404) throw e;
              await github.rest.repos.createRelease({
                owner, repo,
                tag_name: tag,
                target_commitish: context.sha,
                name: tag,
                body: `Draft release for **${tag}** (created by workflow). Artifacts will be attached by CI.`,
                draft: true,
                prerelease: false,
                generate_release_notes: true
              });
            }

  govulncheck:
    if: github.event_name == 'workflow_dispatch'
    name: Security gate (govulncheck FIRST) + PR
    runs-on: ubuntu-latest
    needs: [create-tag]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Verify modules resolve (RO mode)
        run: go list ./... >/dev/null

      # ---- Run govulncheck directly to guarantee PURE JSON ----
      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@latest

      - name: Run govulncheck (pure JSON)
        shell: bash
        run: |
          set -euo pipefail
          BIN="$(go env GOPATH)/bin/govulncheck"
          # write ONLY JSON to file
          "$BIN" -format=json ./... > govuln.json

      - name: Analyze report and stage README/report files
        id: analyze
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const TAG = process.env.RELEASE_TAG;
            const SAFE_TAG = TAG.replace(/\//g, '-');

            // Read raw govuln output (may contain banners / multiple JSONs)
            const rawAll = fs.readFileSync('govuln.json', 'utf8');

            // Extract the FIRST complete JSON object (or array) via brace balancing,
            // skipping junk and respecting string/escape semantics.
            function extractFirstJson(txt) {
              let start = -1;
              let end = -1;
              let depth = 0;
              let inString = false;
              let esc = false;
              let opener = null; // '{' or '['
              for (let i = 0; i < txt.length; i++) {
                const ch = txt[i];

                if (start === -1) {
                  if (ch === '{' || ch === '[') {
                    start = i;
                    opener = ch;
                    depth = 1;
                    inString = false;
                    esc = false;
                  }
                  continue;
                }

                if (inString) {
                  if (esc) { esc = false; continue; }
                  if (ch === '\\') { esc = true; continue; }
                  if (ch === '"') { inString = false; continue; }
                  continue;
                }

                // not inside a string
                if (ch === '"') { inString = true; continue; }
                if (ch === '{' || ch === '[') { depth++; continue; }
                if (ch === '}' || ch === ']') { depth--; if (depth === 0) { end = i; break; } }
              }
              if (start !== -1 && end !== -1) return txt.slice(start, end + 1);
              return null;
            }

            let coreJson = extractFirstJson(rawAll);
            if (!coreJson) {
              core.setFailed('govuln.json does not contain a complete JSON object/array');
              return;
            }

            let doc;
            try {
              doc = JSON.parse(coreJson);
            } catch (e) {
              core.setFailed(`Unable to parse govuln.json (sanitized): ${e.message}`);
              return;
            }

            const count = Array.isArray(doc.vulns) ? doc.vulns.length : 0;
            core.setOutput('count', String(count));

            // Persist tag for later jobs
            fs.mkdirSync('.release', { recursive: true });
            fs.writeFileSync('.release/tag', TAG);

            // Save pretty JSON report to a deterministic path
            const outDir = path.join('reports', 'govulncheck');
            fs.mkdirSync(outDir, { recursive: true });
            const outPath = path.join(outDir, `${SAFE_TAG}.json`);
            fs.writeFileSync(outPath, JSON.stringify(doc, null, 2), 'utf8');

            // Build README section safely (line-by-line; pure ASCII)
            const date = new Date().toISOString().replace(/\.\d+Z$/, 'Z');
            const lines = [
              '<!-- GOVULNCHECK-START -->',
              '### govulncheck',
              '',
              '| Field | Value |',
              '|------:|:------|',
              `| Tag | **${TAG}** |`,
              `| Scan Time (UTC) | ${date} |`,
              `| Findings | **${count}** |`,
              `| Full Report | [${outPath}](${outPath}) |`,
              '',
              '_This section is auto-updated by the e2e release workflow._',
              '<!-- GOVULNCHECK-END -->',
              ''
            ];
            const section = lines.join('\n');

            const startMarker = '<!-- GOVULNCHECK-START -->';
            const endMarker   = '<!-- GOVULNCHECK-END -->';
            let readme = fs.existsSync('README.md') ? fs.readFileSync('README.md', 'utf8') : '';
            if (readme.includes(startMarker) && readme.includes(endMarker)) {
              const pre  = readme.slice(0, readme.indexOf(startMarker));
              const post = readme.slice(readme.indexOf(endMarker) + endMarker.length);
              readme = pre + section + post;
            } else {
              if (readme.length && !readme.endsWith('\n')) readme += '\n';
              readme += section;
            }
            fs.writeFileSync('README.md', readme, 'utf8');

      # Use a PAT if available (needed when org setting blocks Actions from creating PRs)
      - name: Pick token for PR
        id: picktok
        run: |
          if [ -n "${{ secrets.BOT_TOKEN }}" ]; then
            echo "token=${{ secrets.BOT_TOKEN }}" >> $GITHUB_OUTPUT
          else
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
          fi

      - name: Create PR with report & README
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "chore(govulncheck): add report for ${{ env.RELEASE_TAG }} and update README"
          branch: "chore/govulncheck-${{ env.RELEASE_TAG && env.RELEASE_TAG != '' && env.RELEASE_TAG || github.run_id }}-${{ github.run_id }}"
          title: "[vulncheck] report for ${{ env.RELEASE_TAG }}"
          body: |
            This PR adds the **govulncheck** report for `${{ env.RELEASE_TAG }}` and updates the README summary section.
            Findings: `${{ steps.analyze.outputs.count }}`
          labels: |
            security
            automated-pr
          delete-branch: true
          token: ${{ steps.picktok.outputs.token }}
          author: "github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>"
          committer: "github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>"

# --------------------------------------------------------------------
# PATH B: PR merged -> build, tests, image + binaries -> finalize release
# --------------------------------------------------------------------
  release-on-merge:
    # Run only when a PR was merged AND its title starts with "[vulncheck]"
    if: github.event_name == 'pull_request_target' && github.event.pull_request.merged == true && startsWith(github.event.pull_request.title, '[vulncheck]')
    name: Release after PR merge (owner/admin gate)
    runs-on: ubuntu-latest
    steps:
      - name: "Guard: merger must be admin/owner"
        uses: actions/github-script@v7
        with:
          script: |
            const owner  = context.repo.owner;
            const repo   = context.repo.repo;
            const number = context.payload.pull_request.number;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: number });
            if (!pr.merged) core.setFailed('PR is not merged');
            const merger = (pr.merged_by && pr.merged_by.login) ? pr.merged_by.login : context.actor;
            const { data } = await github.rest.repos.getCollaboratorPermissionLevel({ owner, repo, username: merger });
            if (data.permission !== 'admin') core.setFailed(`User ${merger} lacks admin permissions; refusing to release.`);

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.merge_commit_sha }}

      - name: Read tag from .release/tag
        id: tagfile
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f .release/tag ]; then
            echo "Missing .release/tag in merged commit." >&2
            exit 1
          fi
          TAG="$(cat .release/tag)"
          if [[ ! "$TAG" =~ ^release/mark-v[0-9]+-[0-9]+-[0-9]+$ ]]; then
            echo "Tag in .release/tag has wrong format: $TAG" >&2
            exit 1
          fi
          echo "RELEASE_TAG=$TAG" >> "$GITHUB_ENV"
          echo "SAFE_TAG=${TAG//\//-}" >> "$GITHUB_ENV"

      - name: Ensure tag exists
        uses: actions/github-script@v7
        with:
          script: |
            const tag   = process.env.RELEASE_TAG;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            try {
              await github.rest.git.getRef({ owner, repo, ref: `tags/${tag}` });
            } catch (e) {
              core.setFailed(`refs/tags/${tag} does not exist. Run the dispatch path first.`);
            }

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Install eBPF toolchain (clang/llvm/libbpf + bpftool)
        shell: bash
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y clang llvm make gcc libelf-dev libbpf-dev pkg-config
          KREL="$(uname -r)"
          sudo apt-get install -y linux-tools-common linux-tools-generic linux-cloud-tools-generic || true
          sudo apt-get install -y "linux-tools-${KREL}" || true
          BPFOOL=""
          for p in /usr/sbin/bpftool /usr/bin/bpftool "/usr/lib/linux-tools-${KREL}/bpftool" /usr/lib/linux-tools-*/bpftool; do
            if [ -x "$p" ]; then BPFOOL="$p"; break; fi
          done
          if [ -z "$BPFOOL" ]; then
            echo "bpftool not found via apt; building from source..."
            sudo apt-get install -y git build-essential flex bison libcap-dev libzstd-dev
            git clone --depth=1 https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git /tmp/bpf-next
            make -C /tmp/bpf-next/tools/bpf/bpftool
            BPFOOL=/tmp/bpf-next/tools/bpf/bpftool/bpftool
          fi
          echo "BPFOOL=$BPFOOL" >> "$GITHUB_ENV"
          "$BPFOOL" version

      - name: Prebuild eBPF objects
        if: ${{ hashFiles('bpf/Makefile') != '' }}
        working-directory: bpf
        env:
          BPFOOL: ${{ env.BPFOOL }}
        run: make

      - name: Sync modules
        run: |
          go env -w GOPROXY=https://proxy.golang.org,direct
          go mod tidy
          go mod download all

      - name: Build & Test (race)
        run: |
          go build ./...
          go test -race -count=1 ./...

      # ---- Docker image (tag EXACTLY == release tag) ----
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          flavor: |
            latest=false
          tags: |
            type=raw,value=${{ env.SAFE_TAG }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ env.RELEASE_TAG }}

      - name: Build & push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: deploy/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ---- GoReleaser (binaries) with the same tag) ----
      - name: GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          version: latest
          distribution: goreleaser
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GORELEASER_CURRENT_TAG: ${{ env.RELEASE_TAG }}